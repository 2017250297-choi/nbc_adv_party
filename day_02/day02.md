# 파이썬 코루틴
sub-routine: 종속되어있는 루틴
co-roution: 협력적으로 실행되는 루틴. 비동기 실행에서 사용.
```python
# 서브루틴 예시
def func(a):
    return a+1
a=1
b=func(a)
print(b)
```
서브루틴은 결국 순차적으로 처리되는 것이나 다름없다.(동기처리)
**비동기** 프로그래밍은 여러 작업을 **동시에** 처리할 수 있다.

## 파이썬 코루틴
실행중인 함수를 잠시 멈추고 나중에 실행을 재생하는 기능이다.
### 핵심 키워드 yield
만날때 마다 함수 일시중단 후 값을 반환
### 핵심 키워드 next
다음 yield를 만날때까지 코루틴을 다시 시작
### 핵심 키워드 send
코루틴에 값 전달: 다시실행. yield 반환값이 send함수의 인자가 된다.(예시코드참조)
> **Q**:iterable 하면 next()를 쓸수 있다고 알고 있습니다. 코루틴은 iterable한 객체 인건가요?<br>
**A**: 맞습니다.

# Asynco
비동기 프로그래밍을 위한 라이브러리이다.
async: 코루틴 선언
await: 코루틴 안에서 다른 코루틴의 실행완료를 기다림 - 꼭 그 작업이 끝나야 실행이 가능할 때
run(): 코루틴을 시작한다.

# 파이선 패키지 관리
주의: 파일 이름을 모듈과 같은 이름으로 짓지 마라. 파이선, 장고등의 키워드로 이름을 짓지 말라.

## 모듈vs패키지vs라이브러리
- 모듈: 파이썬 코드의 정의와 선언이 담겨있는, 즉 실행가능한 파이썬 파일.
- 패키지: 모듈들이 모여있는 namespace. (.으로 타고들어가는거)
- 라이브러리: 미리 준비된 패키지와 모듈의 모음
## PIP
파이선의 패키지를 관리하는 도구
install, search, 버전지정(==), uninstall

## 의존성 관리란?
외부라이브러리의 관리. 

1. 어떤 버전/패키지가 쓰였는가
2. 어떤 버전/패키지가 쓰일 수 있는가

## 의존성 관리의 문제
패키지와 라이브러리는 의존을 하고 있는 다른 모듈과 패키지도 함께 설치해야한다. 이렇게 의존중인 패키지등에 문제가 생기면 전체에도 문제가 생긴다.

## 관리 방법 1. requeirements.txt
최대한 적게 관리하는 것이 좋다. 그래서 개발용, 테스팅용으로 따로 관리하는 경우가 많다.

### 문제 의식
1. 배포용 패키지와 개발용 패키지가 포함관게일 때 실수가 많이 발생함.(이원화가 안되는 문제, 수작업)
2. 의존관계의 파악이 어렵다.(tracking) 심지어 pip uninstall은 불필요하게 남은 의존 패키지를 남긴다.
3. 통일되지 않은 패키지 관리자와 가상환경(Vrt/venv/conda...)이 야기하는 문제들


## 개선1 - pipenv
임의의 폴더에 pipenv install 실행 -> 가상환경 생성.
run pipenv shell -> 실행
pipenv install django
pipfile파일 생성: 현재 패키지 목록
pipfile.lock파일 생성: 언제나 똑같은 패키지가 설치되도록 보장.
pip install --dev django-debug-toolbar: 개발용에만.
알아서 스냅샷을 이용해 업데이트.
알아서 의존성 패키지들을 게층적으로 보여준다.
버전별 관리가 편리.

### 문제의식
너무 늦은 release주기, 운영체제별 성능 이슈.

## 개선2 - poetry
명령어만 조금 다르다.
poetry.toml과 poetry.lock을 깃헙에 올리면 팀원들이 모두 같은 패키지 설치됨이 보장됨.
poetry shell: 가상환경 실행
설치: poetry add django 
개발용: peorty add --dev django
**검색기능**: poetry search keras
show tree: 계층적으로 의존관계 보여줌
**publish 기능**